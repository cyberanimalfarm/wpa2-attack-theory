### THIS CODE WAS GENERATED BY CHAT GPT TO EXPLAIN THESE CONCEPTS. YMMV

import hashlib
import hmac
import os
import struct


class EAPOLFrame:
    def __init__(self):
        self.version = b'\x01'
        self.type = b'\x03'  # EAPOL-Key
        self.len = b'\x00\x00'  # Placeholder; will be calculated
        self.descriptor_type = b'\x02'  # RSN Key

        # Key Information fields
        self.key_info = b'\x01\x3a'
        self.key_len = b'\x00\x10'  # Corresponds to a 16-byte key (e.g., for CCMP)
        self.replay_counter = b'\x00\x00\x00\x00\x00\x00\x00\x01'
        self.nonce = b'\x00' * 32  # Placeholder
        self.key_iv = b'\x00' * 16
        self.key_rsc = b'\x00' * 8
        self.key_id = b'\x00' * 8
        self.mic = b'\x00' * 16
        self.data_len = b'\x00\x00'
        self.data = b''

    def set_nonce(self, nonce):
        self.nonce = nonce

    def compute_length(self):
        # Compute and set the length field based on the data field
        total_len = len(self.descriptor_type) + len(self.key_info) + len(self.key_len) + \
            len(self.replay_counter) + len(self.nonce) + len(self.key_iv) + \
            len(self.key_rsc) + len(self.key_id) + len(self.mic) + \
            len(self.data_len) + len(self.data)

        self.len = struct.pack('>H', total_len)  # Convert to 2-byte length

    def get_frame(self):
        self.compute_length()
        return self.version + self.type + self.len + self.descriptor_type + \
               self.key_info + self.key_len + self.replay_counter + self.nonce + \
               self.key_iv + self.key_rsc + self.key_id + self.mic + self.data_len + self.data

    def set_mic(self, mic):
        self.mic = mic


# 1. Generate the PSK
def generate_psk(ssid, passphrase):
    return hashlib.pbkdf2_hmac('sha1', passphrase.encode(), ssid.encode(), 4096, 32)


# Pseudo-random function for PTK derivation
def PRF512(key, A, B):
    num_blocks = 4
    R = b''
    for i in range(1, num_blocks + 1):
        hmac_data = A + chr(0x00).encode() + B + chr(i).encode()
        R += hmac.new(key, hmac_data, hashlib.sha1).digest()
    return R


def generate_ptk(pmk, anonce, snonce, ap_mac, client_mac):
    A = b"Pairwise key expansion"
    B = min(ap_mac, client_mac) + max(ap_mac, client_mac) + min(anonce, snonce) + max(anonce, snonce)
    return PRF512(pmk, A, B)


# Compute the MIC over an EAPOL frame
def compute_mic(ptk, eapol_frame):
    # For this demonstration, assume the MIC field is bytes 81-97 in the EAPOL frame
    eapol_for_mic = eapol_frame[:81] + b'\x00' * 16 + eapol_frame[97:]
    return hmac.new(ptk[:16], eapol_for_mic, hashlib.sha1).digest()


# For this example:
ssid = "testSSID"
passphrase = "testPassphrase"
psk = generate_psk(ssid, passphrase)
print(f"PSK: {psk.hex()}")

# Random values for our example
anonce = os.urandom(32)
snonce = os.urandom(32)
ap_mac = os.urandom(6)
client_mac = os.urandom(6)

ptk = generate_ptk(psk, anonce, snonce, ap_mac, client_mac)
print(f"PTK: {ptk.hex()}")

eapol = EAPOLFrame()
eapol.set_nonce(snonce)

mic = compute_mic(ptk, eapol.get_frame())
eapol.set_mic(mic)

print(f"EAPOL Frame: {eapol.get_frame().hex()}")
print(f"MIC: {mic.hex()}")
